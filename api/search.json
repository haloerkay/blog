[{"id":"cd6a12c0c07e3b04d0fd2533bf4aa0fa","title":"防抖与节流","content":"防抖\n\n\n\n\n\n\n\n\n响应函数在事件触发n秒后执行，如果这n秒内重新触发，将重新计时\n在n秒内没有重新触发，则执行响应函数\n其实就是在触发事件一定时间后，再执行响应函数\n类似于游戏中的回城\n函数实现\n/**\n * @desc 函数防抖\n * @param func 函数\n * @param wait 延迟执行毫秒数\n * @param immediate true 表立即执行，false 表非立即执行\n */\nfunction debounce(func, wait, immediate) &#123;\n  let timeout;\n  return function () &#123;\n      //让this指向触发事件的容器\n    const context = this;\n      //获取事件对象\n    const args = arguments;\n    //清除上次的定时器\n    clearTimeout(timeout);\n    if (immediate) &#123;\n      const callNow = !timeout;\n      timeout = setTimeout(() => &#123;\n        timeout = null;\n      &#125;, wait)\n      if (callNow) func.apply(context, args)\n    &#125;\n    else &#123;\n      timeout = setTimeout(() => &#123;\n        func.apply(context, args)\n      &#125;, wait);\n    &#125;\n  &#125;\n&#125;\n\n\n\n节流\n\n\n\n\n\n\n\n\n在规定时间内，只能触发一次函数，如果在规定时间内触发多次，只有一次生效\n其实就是在规定时间内，最多执行一次响应函数\n类似游戏中的普攻\n/**\n * @desc 函数节流\n * @param func 函数\n * @param wait 延迟执行毫秒数\n * @param type 1 表时间戳版，2 表定时器版\n */\nfunction throttle(func, wait ,type) &#123;\n    if(type===1)&#123;\n        let previous = 0;\n    &#125;else if(type===2)&#123;\n        let timeout;\n    &#125;\n    return function() &#123;\n        let context = this;\n        let args = arguments;\n        if(type===1)&#123;\n            let now = Date.now();\n            if (now - previous > wait) &#123;\n                func.apply(context, args);\n                previous = now;\n            &#125;\n        &#125;else if(type===2)&#123;\n            if (!timeout) &#123;\n                timeout = setTimeout(() => &#123;\n                    timeout = null;\n                    func.apply(context, args)\n                &#125;, wait)\n            &#125;\n        &#125;\n\n    &#125;\n&#125;\n\n","slug":"防抖与节流","date":"2022-10-14T06:34:22.375Z","categories_index":"前端","tags_index":"JavaScript","author_index":"haloerkay"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-10-14T03:16:20.055Z","categories_index":"","tags_index":"","author_index":"haloerkay"},{"id":"397589cbdfc7b4478e47c07e988fa160","title":"快速了解this指针","content":"前言先说下结论\n在ES5及以前中，this最终指向调用它的对象，与this定义时的位置无关。\n在ES6中，箭头函数的this指向函数定义时的this，而不是执行时。\n例1function fn()&#123;\n    var user = \"破壁者\";\n    console.log(this.user); //undefined\n    console.log(this); //Window\n&#125;\nfn();\n//此处的fn()相当于window.fn()\n\n函数fn中的this指向window，最后调用的函数fn()，实际上是被window点出来的\n例2var obj = &#123;\n    user:\"破壁者\",\n    fn:function()&#123;\n        console.log(this.user); //破壁者\n    &#125;\n&#125;\nobj.fn();\n\n回顾最开始的那句话，this最终指向调用它的对象\n那么这个例子轻易就得出结果了，this指向obj\n接下来再看看下面这一个例子\nvar obj = &#123;\n    user:\"破壁者\",\n    fn:function()&#123;\n        console.log(this.user); //破壁者\n    &#125;\n&#125;\nwindow.obj.fn();       //做个标记①\n\n看到这里，可能会有些疑问，不是说this最终指向调用它的对象吗？此处this为什么不是指向window呢\n不要慌不要慌~\n先看看下面这个例子\nvar obj = &#123;\n    a:10,\n    b:&#123;\n        a:12,\n        fn:function()&#123;\n            console.log(this.a); //12\n        &#125;\n    &#125;\n&#125;\nobj.b.fn();\n\n看到这里，或许会豁然开朗，函数fn中的this指向最后调用它的对象b。虽然最开始是由obj点出来的，但是this并没有执行它。\n那么我们再来类比上面的①处的window.obj.fn();,最后调用它的对象是obj，那么this就指向obj了\n看完上面的例子\nES5中this指向可总结为三点\n\n\n\n\n\n\n\n\n\n情况1：如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window，但是我们这里不探讨严格版的问题，你想了解可以自行上网查找。\n情况2：如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。\n情况3：如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象，例子3可以证明，如果不相信，那么接下来我们继续看几个例子。\n例3除此以外，还有一些特殊情况\nvar obj = &#123;\n    a:10,\n    b:&#123;\n        a:12,\n        fn:function()&#123;\n            console.log(this.a); //undefined\n            console.log(this); //window\n        &#125;\n    &#125;\n&#125;\nvar j = obj.b.fn;\nj();\nwindow.j();//同上,j为window直属的属性\n\n这里虽然将对象b中的fn函数赋值给j,但是并没有调用，所以还可以借助开头那句话（最终指向调用它的对象），在这里也就是window\n还有一个容易忽略的一点就是setTimeout\nvar name = \"windowsName\";\n\nvar a = &#123;\n    name : \"Cherry\",\n    \n    func1: function () &#123;\n        console.log(this.name)     \n    &#125;,\n    func2: function () &#123;\n        setTimeout(  function () &#123;\n            this.func1()\n        &#125;,100);\n    &#125;\n\n&#125;;\n\na.func2()     // this.func1 is not a function\n\n因为setTimeout是window提供的方法，里面的this指向window\n箭头函数中的thisvar name = \"windowsName\";\n\nvar a = &#123;\n    name : \"Cherry\",\n\n    func1: function () &#123;\n        console.log(this.name)     \n    &#125;,\n\n    func2: function () &#123;\n        setTimeout( () => &#123;\n            this.func1()\n        &#125;,100);\n    &#125;\n\n&#125;;\n\na.func2()     // Cherry\n\n箭头函数中的this，在函数定义时就已经确定，与执行时无关\n参考文章:\nthis、apply、call、bind\n","slug":"快速了解this指针","date":"2022-09-14T16:00:00.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"haloerkay"},{"id":"d3e5941394e4ad3a2ef49c227f52e4fe","title":"js异步编程","content":"前言JavaScript语言的执行环境是单线程的，也就是说一次只能完成一个任务，完成前面一个任务后，再去执行下一个任务。\n虽然这种模式不像多线程那么复杂，但是如果执行的一个任务耗时很长，那么就会造成阻塞，无法执行后面的任务，进而影响用户的体验。\n为了解决这个问题，JS把任务的执行模式分为异步和同步两种\n为了区别同步和异步，这里举一个生活中的例子\n假如要完成洗衣服和拖地这两项任务，\n同步：把衣服放进洗衣机处理好后，一直在旁边等待，直到洗完衣服并晾晒后，再去拖地\n异步：把衣服放进洗衣机处理好后，就去拖地，拖完地后再来处理洗完的衣服。\n这样的说法可能并不是很严谨，接下来会在事件循环部分中具体介绍\n异步场景详细介绍异步之前，先来回顾下日常用到异步的场景\n\najax请求\najax(url, () => &#123;\n    // 处理逻辑\n&#125;)\n\n读取文件\nfs.readFile('/', 'utf8' , (err, data) => &#123;\n\t//  处理逻辑\n&#125;)\n\n定时器\nsetTimeOut(()=>&#123;\n\t//\t处理逻辑\n&#125;,100)\n\n发布订阅、Promise等等\n\n\n可以说前端项目中，几乎离不开异步任务\n事件循环先来看一张图\n\n先来一步步解读：\n\n同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数\n\n当指定的事情完成时，Event Table会将这个函数移入Event Queue。\n\n主线程内的任务执行完毕为空后，会去Event Queue读取对应的函数，进入主线程执行。\n\n上述过程会不断重复，也就是常说的Event Loop(事件循环)\n\n\n直接上理论可能不够明显，再通过一个例子来解释\nlet data = [];\n$.ajax(&#123;\n    url:www.javascript.com,\n    data:data,\n    success:() => &#123;\n        console.log('发送成功!');\n    &#125;\n&#125;)\nconsole.log('代码执行结束');\n\n上面是一段简易的ajax请求代码：\n\najax进入Event Table，注册回调函数success。\n执行console.log(‘代码执行结束’)。\najax事件完成，回调函数success进入Event Queue。\n主线程从Event Queue读取回调函数success并执行。\n\n借助这个例子，瞬间就清晰多了\n宏任务 微任务宏任务和微任务都属于异步任务，但是他们执行的先后顺序有所不同\n\njs异步中，遇到宏任务，先执行宏任务，将宏任务放入Event Queue中，然后再执行微任务，将微任务放入Event Queue。但是，这两个Event Queue并不是同一个Queue,当往外拿的时候，先拿出微任务，再拿出宏任务。\n常见的宏任务：setTimeout，setInterval、setImmediate。\n常见的微任务：原生Promise(有些实现的promise将then方法放到了宏任务中)、process.nextTick、Object.observe(已废弃)、 MutationObserver\n看完上面的介绍，来看段代码\nconsole.log('script start');\n\nsetTimeout(function() &#123;\n  console.log('setTimeout');\n&#125;, 0);\n\nPromise.resolve().then(function() &#123;\n  console.log('promise1');\n&#125;).then(function() &#123;\n  console.log('promise2');\n&#125;);\n\nconsole.log('script end');\n\n输出结果为script start, script end, promise1, promise2, setTimeout \n前两个输出都是同步任务，故最先输出\n后面三个输出，有宏任务和微任务之分，故promise1和promise2在setTimeout之前\nsetTimeout(()&#x3D;&gt;{},0)分析setTimeout(()=>&#123;\nconsole.log('111')\n&#125;,0)\nconsole.log(\"222\")\n\n输出为：222  111\nconsole.log(‘111’)进入Event Table并注册，计时开始\n执行console.log(‘222’)\nconsole.log(‘111’)进入Event Queue，查看主线程是否为空\n主线程任务执行完毕，执行Event Queue中的任务console.log(‘111’)\n\n\n\n\n\n\n\n\n\n所以说，setTimeout这个函数，是经过指定时间后，把要执行的任务加入到Event Queue中\n注：HTML5标准规定了setTimeout的第二个参数的最小值（最短间隔），不得低于4毫秒\n","slug":"js异步编程","date":"2022-09-14T16:00:00.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"haloerkay"}]